"""
Centralized allocation report management.

This module defines all allocation report types, their schemas, and provides
a unified interface for generating and saving reports to the database.
"""

from enum import Enum
from dataclasses import dataclass
from typing import Dict, Optional
import pandas as pd
import logging
from datetime import datetime

from code.logics.db import AllocationReportsModel
from code.logics.core_utils import CoreUtils

logger = logging.getLogger(__name__)


class ReportType(str, Enum):
    """
    Enumeration of all available allocation report types.

    Primary Allocation Reports (generated by allocation.py):
    - BUCKET_SUMMARY: Vendor distribution by bucket with details
    - BUCKET_AFTER_ALLOCATION: Post-allocation bucket state
    - ROSTER_ALLOTMENT: Vendor assignments per month

    Bench Allocation Reports (generated by bench_allocation.py):
    - BENCH_ROSTER_ALLOTMENT: Updated roster with bench allocations
    - BENCH_BUCKET_AFTER_ALLOCATION: Bucket state after bench allocation
    """
    # Primary allocation reports
    BUCKET_SUMMARY = "bucket_summary"
    BUCKET_AFTER_ALLOCATION = "bucket_after_allocation"
    ROSTER_ALLOTMENT = "roster_allotment"

    # Bench allocation reports
    BENCH_ROSTER_ALLOTMENT = "bench_roster_allotment"
    BENCH_BUCKET_AFTER_ALLOCATION = "bench_bucket_after_allocation"


@dataclass
class ReportMetadata:
    """Metadata for a report type."""
    report_type: ReportType
    description: str
    phase: str  # "primary" or "bench"
    schema_description: str  # Description of expected DataFrame columns
    generated_by: str  # Module that generates this report


# Report registry with metadata
REPORT_REGISTRY: Dict[ReportType, ReportMetadata] = {
    ReportType.BUCKET_SUMMARY: ReportMetadata(
        report_type=ReportType.BUCKET_SUMMARY,
        description="Vendor distribution summary by bucket with detailed vendor lists",
        phase="primary",
        schema_description="Columns: Platform, Location, Month, Skills, Skill_Count, Vendor_Count, States_Available, ReportSection",
        generated_by="allocation.ResourceAllocator"
    ),
    ReportType.BUCKET_AFTER_ALLOCATION: ReportMetadata(
        report_type=ReportType.BUCKET_AFTER_ALLOCATION,
        description="Bucket allocation statistics showing allocated vs unallocated vendors",
        phase="primary",
        schema_description="Columns: Platform, Location, Month, Skills, Skill_Count, Total_Vendors, Allocated, Unallocated, Allocation_Rate, Allocated_States, Unallocated_States",
        generated_by="allocation.ResourceAllocator"
    ),
    ReportType.ROSTER_ALLOTMENT: ReportMetadata(
        report_type=ReportType.ROSTER_ALLOTMENT,
        description="Vendor-level allocation showing which vendors were assigned to which forecasts",
        phase="primary",
        schema_description="Columns: FirstName, LastName, CN, OPID, PrimaryPlatform, PrimaryMarket, NewWorkType, Location, State, PartofProduction, Production%, Status, {Month}_LOB, {Month}_State, {Month}_Worktype (for each month)",
        generated_by="allocation.ResourceAllocator"
    ),
    ReportType.BENCH_ROSTER_ALLOTMENT: ReportMetadata(
        report_type=ReportType.BENCH_ROSTER_ALLOTMENT,
        description="Updated roster allotment including bench allocations (Status='Allocated (Bench)' for bench vendors)",
        phase="bench",
        schema_description="Same as ROSTER_ALLOTMENT but with bench allocation updates",
        generated_by="bench_allocation.BenchAllocator"
    ),
    ReportType.BENCH_BUCKET_AFTER_ALLOCATION: ReportMetadata(
        report_type=ReportType.BENCH_BUCKET_AFTER_ALLOCATION,
        description="Bucket state after bench allocation showing vendor utilization",
        phase="bench",
        schema_description="Columns: Platform, Location, Month, Skills, Skill_Count, Total_Vendors, Allocated, Unallocated, Allocation_Rate, Allocated_States, Unallocated_States",
        generated_by="bench_allocation.BenchAllocator"
    )
}


class AllocationReportManager:
    """
    Centralized manager for allocation reports.

    Handles saving, updating, and retrieving allocation reports with
    standardized metadata and error handling.
    """

    def __init__(self, core_utils: CoreUtils):
        """
        Initialize report manager.

        Args:
            core_utils: CoreUtils instance for database access
        """
        self.core_utils = core_utils

    def save_report(
        self,
        df: pd.DataFrame,
        report_type: ReportType,
        execution_id: str,
        month: str,
        year: int,
        created_by: str,
        updated_by: Optional[str] = None,
        upsert: bool = True
    ) -> bool:
        """
        Save or update a report in the database.

        Args:
            df: Report DataFrame
            report_type: Type of report (from ReportType enum)
            execution_id: Execution UUID
            month: Report month
            year: Report year
            created_by: User/system that created the report
            updated_by: User/system updating the report (defaults to created_by)
            upsert: If True, update existing report; if False, always create new

        Returns:
            True if successful, False otherwise
        """
        if updated_by is None:
            updated_by = created_by

        try:
            # Validate report type
            if report_type not in REPORT_REGISTRY:
                logger.error(f"Unknown report type: {report_type}")
                return False

            metadata = REPORT_REGISTRY[report_type]
            logger.info(f"Saving {metadata.phase} report: {report_type.value}")
            logger.debug(f"  Description: {metadata.description}")
            logger.debug(f"  Rows: {len(df)}, Columns: {len(df.columns)}")

            # Get database manager
            db_manager = self.core_utils.get_db_manager(
                AllocationReportsModel,
                limit=1000,
                skip=0,
                select_columns=None
            )

            # Convert DataFrame to JSON
            report_json = df.to_json(orient='records', date_format='iso')

            with db_manager.SessionLocal() as session:
                if upsert:
                    # Try to find existing report
                    existing = session.query(AllocationReportsModel).filter(
                        AllocationReportsModel.execution_id == execution_id,
                        AllocationReportsModel.ReportType == report_type.value
                    ).first()

                    if existing:
                        # Update existing
                        existing.ReportData = report_json
                        existing.UpdatedDateTime = datetime.now()
                        existing.UpdatedBy = updated_by
                        logger.info(f"✓ Updated existing {report_type.value} report (execution_id: {execution_id})")
                    else:
                        # Create new
                        new_report = AllocationReportsModel(
                            execution_id=execution_id,
                            Month=month,
                            Year=year,
                            ReportType=report_type.value,
                            ReportData=report_json,
                            CreatedDateTime=datetime.now(),
                            CreatedBy=created_by,
                            UpdatedDateTime=datetime.now(),
                            UpdatedBy=updated_by
                        )
                        session.add(new_report)
                        logger.info(f"✓ Created new {report_type.value} report (execution_id: {execution_id})")
                else:
                    # Always create new (no upsert)
                    new_report = AllocationReportsModel(
                        execution_id=execution_id,
                        Month=month,
                        Year=year,
                        ReportType=report_type.value,
                        ReportData=report_json,
                        CreatedDateTime=datetime.now(),
                        CreatedBy=created_by,
                        UpdatedDateTime=datetime.now(),
                        UpdatedBy=updated_by
                    )
                    session.add(new_report)
                    logger.info(f"✓ Created new {report_type.value} report (execution_id: {execution_id})")

                session.commit()
                return True

        except Exception as e:
            logger.error(f"Failed to save {report_type.value} report: {e}", exc_info=True)
            return False

    def get_report(
        self,
        execution_id: str,
        report_type: ReportType
    ) -> Optional[pd.DataFrame]:
        """
        Retrieve a report from the database.

        Args:
            execution_id: Execution UUID
            report_type: Type of report to retrieve

        Returns:
            DataFrame if found, None otherwise
        """
        try:
            db_manager = self.core_utils.get_db_manager(
                AllocationReportsModel,
                limit=1,
                skip=0,
                select_columns=None
            )

            with db_manager.SessionLocal() as session:
                report = session.query(AllocationReportsModel).filter(
                    AllocationReportsModel.execution_id == execution_id,
                    AllocationReportsModel.ReportType == report_type.value
                ).first()

                if not report:
                    logger.warning(f"Report {report_type.value} not found for execution {execution_id}")
                    return None

                # Parse JSON to DataFrame
                import json
                report_data = json.loads(report.ReportData)
                df = pd.DataFrame(report_data)

                logger.info(f"Retrieved {report_type.value} report: {len(df)} rows")
                return df

        except Exception as e:
            logger.error(f"Failed to retrieve {report_type.value} report: {e}", exc_info=True)
            return None

    @staticmethod
    def list_available_reports() -> Dict[ReportType, ReportMetadata]:
        """
        Get metadata for all available report types.

        Returns:
            Dictionary mapping report type to metadata
        """
        return REPORT_REGISTRY.copy()

    @staticmethod
    def get_report_metadata(report_type: ReportType) -> Optional[ReportMetadata]:
        """
        Get metadata for a specific report type.

        Args:
            report_type: Report type to query

        Returns:
            ReportMetadata if found, None otherwise
        """
        return REPORT_REGISTRY.get(report_type)